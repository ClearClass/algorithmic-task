package lib.clearclass.tasks;

/** Примечание:
 * 
 * Данный алгоритм, приводимый здесь в ознакомительных целях, не является общим,
 * поскольку при некоторых значениях N и M (например, при N=9 и M=6, N=30 и M=26),
 * текущий курсор (pos) возвращается в исходную точку (x[0]) раньше, чем обойдет 
 * все остальные элементы массива, и таким образом перестановка будет выполнена 
 * лишь частично. Для получения общего решения можно воспользоваться стандартным
 * алгоритмом поворота каждой части в отдельности, и затем поворота всего массива 
 * целиком.
 * 
 */

public class ArrayRevert {
	@Deprecated
	public static void revert(int[] x, int M) {
		int N = x.length;
		int pos = 0;       // текущая позиция (индекс) перестановки
		int tmp1 = x[pos]; // элемент на старой позиции
		int tmp2;          // элемент на новой позиции
				
		if((N-M)!=M) {// если две части не равны
			do {
				pos = pos + ((pos<M)?N-M:-M); // вычисляем новую позицию
				tmp2 = x[pos];                // запоминаем ее содержимое
				x[pos] = tmp1;                // переносим старый элемент
				tmp1 = tmp2;                  // старым элементом становится текущий
			} while(pos!=0);
		} else {     // если обе части одинаковы
			for ( ; pos<N/2; pos++){
				tmp2 = x[N/2+pos];
				x[N/2+pos] = x[pos];
				x[pos] = tmp2;
			}
		}
	}
}